#include<iostream>
#include<queue>
#include<map>
using namespace std;

class Node {
public:
    Node* left;
    Node* right;
    int data;

    Node(int d) : left(NULL), right(NULL), data(d){ }
};

void solve1(Node* root, vector<int>& ans, int level){
    if(root == NULL) return;

    if(level == ans.size()) ans.push_back(root->data);
    solve1(root->right, ans, level + 1);
    solve1(root->left, ans, level + 1);
}

vector<int> rightView(Node* root){
    vector<int> ans;
    solve1(root, ans, 0);
    return ans;
}

void solve(Node* root, vector<int>& ans, int level){
    if(root == NULL) return ;

    if(level == ans.size()) ans.push_back(root->data);

    solve(root->left, ans, level + 1);
    solve(root->right, ans, level + 1);
}

vector<int> leftView(Node* root){
    //we have to print every level first node from left to right
    //how will to identify the 1st node?
    //track the levels
    //if(lvl == vector.size) //we have entered in a new level then store in the vector
    vector<int> ans;
    solve(root, ans, 0);
    return ans;
}

vector<int> bottomView(Node* root){
    vector<int> ans;

    if(root == NULL) return ans;
    
    map<int, int> topNode;
    queue<pair<Node*, int>> q;
    q.push(make_pair(root, 0));

    while(!q.empty()){
        pair<Node*, int> temp = q.front();
        Node* frontNode = temp.first;
        q.pop();
        int hd = temp.second;

        topNode[hd] = frontNode->data;

        if(frontNode->left) q.push(make_pair(frontNode->left, hd - 1));
        if(frontNode->right) q.push(make_pair(frontNode->right, hd + 1));
    }
    for(auto i : topNode){
        ans.push_back(i.second);
    }
    return ans;
}

vector<int> topView(Node* root){
    vector<int> ans;

    if(root == NULL) return ans;

    map<int, int> topNode;
    queue<pair<Node*, int>> q;
    q.push(make_pair(root, 0));

    while(!q.empty()){
        pair<Node*, int> temp = q.front();
        Node* frontNode = temp.first;
        q.pop();
        int hd = temp.second;

        // if one value is present for a HD then do nothing
        if(topNode.find(hd) == topNode.end()){
            topNode[hd] = frontNode->data;
        }

        if(frontNode->left) q.push(make_pair(frontNode->left, hd - 1));
        if(frontNode->right) q.push(make_pair(frontNode->right, hd + 1));
    }
    for(auto i : topNode){
        ans.push_back(i.second);
    }
    return ans;
}

vector<int> verticalTraversal(Node* root){
    //we use number line concept here
    //and identify horizontal distance from root node
    //create a mapping of HD with level-wise node or work will be done
    //map<HD, map<level, vector<list of nodes>>> nodes;
    //required horizontal distance and level
    //queue<pair<Node*, pair<HD, lvl>>>
    map<int, map<int, vector<int> > > nodes;
    queue<pair<Node* , pair<int, int>>> q;
    vector<int> ans;

    if(root == NULL) return ans;
    q.push(make_pair(root, make_pair(0,0)));

    while(!q.empty()){
        pair<Node* , pair<int, int>> temp = q.front();
        Node* frontNode = temp.first;
        q.pop();
        int hd = temp.second.first;
        int lvl = temp.second.second;

        nodes[hd][lvl].push_back(frontNode->data);

        if(frontNode->left){
            q.push(make_pair(frontNode->left, make_pair(hd - 1, lvl + 1)));
        }

        if(frontNode->right){
            q.push(make_pair(frontNode->right, make_pair(hd + 1, lvl + 1)));
        }
    }
    for(auto i : nodes){
        for(auto j : i.second)
        for(auto k : j.second){
            ans.push_back(k);
        }
    }
    return ans;
}

void traverseLeft(Node* root, vector<int>& result){
    if((root == NULL) || (root->left == NULL && root->right == NULL)) {
        return;
    }
    result.push_back(root->data);

    if(root->left) {
        traverseLeft(root->left, result);
    } else {
        traverseLeft(root->right, result);
    }
}

void traverseLeaf(Node* root, vector<int>& result){
    if(root == NULL) return;

    if(root->left == NULL && root->right == NULL){
        result.push_back(root->data);
    }
    traverseLeaf(root->left, result);
    traverseLeaf(root->right, result);
}

void traverseRight(Node* root, vector<int>& result){
    //follow postOrder tarversal
    if((root == NULL) || (root->left == NULL && root->right == NULL)){
        return;
    }
    if(root->right) {
        traverseRight(root->right, result);
    } else {
        traverseRight(root->left, result);
    }
    result.push_back(root->data);
}

vector <int> boundaryTraversal(Node* root){
    vector<int> ans;
    if(root == NULL) return ans;

    //first push the root data
    ans.push_back(root->data);

    //tarverse left part
    traverseLeft(root->left, ans);
    //traverse left subtree leaf nodes
    traverseLeaf(root->left, ans);
    //traverse right subtree leaf nodes
    traverseLeaf(root->right, ans);
    
    //tarverse right part
    traverseRight(root->right, ans);

    return ans;
} 

vector<int> zigzagTraversal(Node* root){
    vector<int> ans;
    queue<Node*> q;
    if(root == NULL) return ans;

    q.push(root);
    
    bool leftToRight = true;
    while(!q.empty()){
        int size = q.size();
        vector<int> temp(size);

        for(int i=0;i<size;i++){
            Node* node = q.front();
            q.pop();

            int index = leftToRight ? i : size - i - 1;
            temp[index] = node->data;

            if(node->left) q.push(node->left);
            if(node->right) q.push(node->right);
        }
        leftToRight = !leftToRight;
        for(auto it : temp){
            ans.push_back(it);
        }
    }
    return ans;
}

void levelOrderTraversal(Node* root){
    queue<Node*> q;
    q.push(root);

    while(!q.empty()){
        Node* node = q.front();
        q.pop();

        cout<<node->data<<" ";

        if(node->left) q.push(node->left);
        if(node->right) q.push(node->right);

    }
}

Node* buildTree(Node* root){
    int data;
    cin>>data;

    if(data == -1) return NULL;

    root = new Node(data);

    root->left = buildTree(root->left);
    root->right = buildTree(root->left);

    return root;
}

int main(){
    Node* root = NULL;
    // 1 3 7 -1 -1 11 -1 -1 5 17 -1 -1 -1
    root = buildTree(root);
    levelOrderTraversal(root);
    cout<<endl;
    vector<int> ans = rightView(root);
    for(auto it : ans){
        cout<<it<<" ";
    }
    cout<<endl;
}
